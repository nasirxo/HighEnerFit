{
          "Tsallis Equation (N-q-T)": "+-----------------------------------------------------------------------------------+\n|  THIS IS AN EXAMPLE FOR WRITING NEW EQUATION  |\n+-----------------------------------------------------------------------------------+\n\n#EQUATION_NAME\neq_name = 'Tsallis Fit'\n\n#INITIAL_GUESS\np0 = [2*np.pi*np.max(y), 1.159, 0.0979] \n\n#FIX_PARAMETERS\nmass\n\n#FUNCTION\ndef fit_func(x, N, q, T):\n    pt = x\n    mt = np.sqrt(pt**2 + mass**2)\n    return N * mt * (1 + (q - 1) * (mt / T))**(-q/(q-1))\n\n#PARAMETERS_BOUNDS\nbounds = ( (0,1,0) , (10000000,2,1) )",
          "Tsallis Equation (N-q-T-Bt)": "\n#EQUATION_NAME\neq_name = 'Tsallis Fit'\n\n#INITIAL_GUESS\np0 = [2*np.pi*np.max(y), 1.159, 0.0979, 0.35]\n\n#FIX_PARAMETERS\nmass\n\n#FUNCTION\ndef fit_func(x, N, q, T , Bt):\n    pt = x\n    mt = np.sqrt(pt**2 + mass**2)\n    G = np.sqrt(1/(1-Bt**2))\n    return 2*np.pi*N*pt*G*(mt-(pt*Bt))*( 1 + G * ((q-1)*(mt-pt*Bt))/T ) ** (-q/(q-1))\n\n#PARAMETERS_BOUNDS\nbounds = ( (-np.inf,1.001,0,0) , (np.inf,2,1,1) )",
          "Hagedron Equation (N-n-T-Bt)": "\n#EQUATION_NAME\neq_name = 'Tsallis Fit'\n\n#INITIAL_GUESS\np0 = [2*np.pi*np.max(y), 1.159, 0.0979, 0.35]\n\n#FIX_PARAMETERS\nmass\n\n#FUNCTION\ndef fit_func(x, N, n, T , Bt):\n    pt = x\n    mt = np.sqrt(pt**2 + mass**2)\n    G = np.sqrt(1/(1-Bt**2))\n    return 2*np.pi*N*pt*( 1 + G * ((mt-pt*Bt)/(n*T)) )** -n\n\n#PARAMETERS_BOUNDS\nbounds = ( (-np.inf,0,0,0) , (np.inf,20,1,1) )",
          "Fokker-Planck (A-b-c-d-T)": "#EQUATION_NAME\neq_name = 'Fokker-Planck Fit'\n\n#INITIAL_GUESS\np0 = [2*np.pi*np.max(y), 1.159, 0.0979, 0.35,0.1,]\n\n#FIX_PARAMETERS\nmass\n\n#FUNCTION\ndef fit_func(x, A, b, c, d, T):\n    pt = x\n    Et = np.sqrt(pt**2 + mass**2)\n    N = np.exp(-b/T)*np.arctan(Et/b)\n    D = (1+(Et/b)**d)**c\n    return A*(N/D)\n\n#PARAMETERS_BOUNDS\nbounds = ( (-np.inf,0,0,0,0) , (np.inf,np.inf,np.inf,np.inf,1) )",
          "Hagedron Equation (A-n-Po)": "\n#EQUATION_NAME\neq_name = 'Hagedron Fit'\n\n#INITIAL_GUESS\np0 = [2*np.pi*np.max(y), 1.159, 0.0979]\n\n#FUNCTION\ndef fit_func(x, A, n, Po):\n    return A*x*(1+(x/Po))**-n\n\n#PARAMETERS_BOUNDS\nbounds = ( (0,0,0) , (np.inf,20,1) )\n",
          "Gaussian Fit": "#EQUATION_NAME\neq_name = 'Gaussian Fit'\n\n#INITIAL_GUESS\np0 = [np.max(y), np.mean(x), np.std(x)]\n\n#FUNCTION\ndef fit_func(x, A, mu, sigma):\n    return A * np.exp(-(x - mu)**2 / (2 * sigma**2))\n\n#PARAMETERS_BOUNDS\nbounds = ((0, -np.inf, 0), (np.inf, np.inf, np.inf))",
          "TBW (N,B,q,T)": "#EQUATION_NAME\neq_name = 'Tsallis Blast Wave Fit'\n\n#INITIAL_GUESS\np0 = [2*np.pi*np.max(y), 0.001, 1.0, 0.160]\n\n#FIX_PARAMETERS\nmass\n\n#FUNCTION\ndef fit_func(x, N, beta, q, T0):\n    n0 = 1\n    pt = np.asarray(x, dtype=float)\n    R = 1.2 * 196.97**(1/3)\n    r_grid = np.linspace(0, R, 50)\n    phi_grid = np.linspace(-np.pi, np.pi, 50)\n    mt = np.sqrt(pt**2 + mass**2)\n    p_ = pt[:, None, None]\n    mt_ = mt[:, None, None]\n    r_ = r_grid[None, :, None]\n    phi_ = phi_grid[None, None, :]\n    rho = np.arctanh(0.5 * beta * (n0 + 2) * (r_ / R)**n0)\n    w = np.sinh(rho)\n    z = np.cosh(rho)\n    f = (1 + ((q - 1) / T0) * (mt_ * z - p_ * w * np.cos(phi_)))**(-q / (q - 1))\n    integrand = p_ * mt_ * r_ * f\n    phi_int = simpson(integrand, x=phi_grid, axis=2)\n    r_int = simpson(phi_int, x=r_grid, axis=1)\n    return N * r_int # removed -> / np.maximum(pt, 1e-10)\n\n#PARAMETERS_BOUNDS\nbounds = ((0.0001, 0.01, 1.001, 0.0), (1000000, 1.0, 2.0, 1.0))\n\n#CUSTOM_PARAMETER_NAMES\ncustom_names = {\"N\": \"Normalization\", \"beta\": \"\u03b2\", \"q\": \"q\", \"t0\": \"T\u2080\", \"n0\": \"n\"}",
          "BGBW (N,To,BTo)": "#EQUATION_NAME\neq_name = 'Boltzman Blast Wave Fit'\n\n#INITIAL_GUESS\np0 = [1.0, 0.160, 0.5]\n\n#FIX_PARAMETERS\nmass\n\n#FUNCTION\ndef fit_func(x, N, T01, betaT1 , mass):\n    pt = np.asarray(x, dtype=float)\n    mt = np.sqrt(pt**2 + mass**2)\n    R = 1.2\n    r_grid = np.linspace(0, R, 50)\n    result = np.zeros_like(pt)\n    for i, (p, m) in enumerate(zip(pt, mt)):\n        integrand = []\n        for r in r_grid:\n            rho1 = np.arctanh(betaT1 * (r / R))\n            I0_term = sp.iv(0, p * np.sinh(rho1) / T01)\n            K1_term = sp.kv(1, m * np.cosh(rho1) / T01)\n            integrand.append(r * I0_term * K1_term)\n        r_int = simpson(integrand, x=r_grid)\n        result[i] = p * m * r_int\n    return C1 * result\n\n#PARAMETERS_BOUNDS\nbounds = ((0.0001, 0.01, 0.0), (100000, 1.0, 1.0))\n\n#CUSTOM_PARAMETER_NAMES\ncustom_names = {\"N\": \"Normalization\", \"T01\": \"T\u2080\u2081\", \"betaT1\": \"\u03b2T\u2081\"}"
}
